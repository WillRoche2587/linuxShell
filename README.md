# linuxShell

Background:
This C program implements a Unix-like shell with features including command history navigation, piping, I/O redirection, background execution, and built-in commands (cd, exit). It operates in non-canonical terminal mode to enable real-time input processing (e.g., arrow keys for history). The shell leverages system calls like fork, execvp, pipe, and chdir to manage processes, directories, and inter-process communication while maintaining a buffer for command history. The code is thoroughly annotated with comments in an effort to make everything as clear as possible. I also tested every basic implementation and edge case as rigorously as I could on the VM.

I. Display Current Working Directory in Prompt
This requirement was implemented through the print_prompt function. Essentially, it creates a character array and uses the getcwd() command to start with the complete working directory path. From there, it does an edge case check for the root directory (as it's formatted differently than other directories), and then loops through the path while updating last_dir to point to the character after the last / it encounters, which would indicate the current directory. The edge case of a path like /home/ is handled in an if statement, and then the prompt is printed (osc:*last directory*>). This happens every time a command is executed, and the prompt is reset.

II. Maintain Working Directory State
This essentially means that the working directory can be changed with cd, which is implemented in the handle_cd_and_exit function. This function is called in main, and after handled, the loop will skip to the next iteration.  First, it checks if the first argument is exit, in which case, the program will exit. Then, if the first argument is cd, the program will check the second argument. If it's empty, an error will print; otherwise, the chdir system call will change the directory to the one specified in the second argument. An error will print if there is no such directory or if the change fails.
III. Child Process Creation and Command Execution

This requirement is dealt with in my run_instruction function. Naturally, it begins with a fork, and an error check to ensure that it worked properly. From there, for the child process’s case, it will begin by checking the input and output files for any redirection needed. If necessary, an output redirection opens a file for writing and redirects the output to the file. Similarly, an input redirection opens the file for reading, and redirects the input to the file. After those checks, execvp is run on the first argument with any given parameters, as explained in the project instructions. After execvp error checks, it then moves on to the parent process. Here, it checks if the command was meant to be run in the background (which is dealt with in my divide_args function), and if so, it doesn’t wait for the child to complete. Otherwise, waitpid is called, and the parent waits until the child process is finished.

IV. Repeat Last Executed Command
This is a basic, most recent history command. Essentially, when the user types !!, it is meant to re-run the most recent command. Since the implementation is minimal, I decided to put this check in my main method, doing a comparison with the input and !! to see if they match. If they do, it then checks that there was a command typed before it as a basic error check. From there, it uses the buffer made for the arrow keys to navigate the history to copy the most recent command into an array, and then print it. From there, it copies this command into the input, so the rest of the program can properly execute it. The other case is if the input isn’t !!, which just adds the input to the buffer using my helper function as usual (assuming it’s a valid command and it wasn’t the same as the most recently typed).

V. Input and Output Redirection
Though this is slightly referenced in my child process creation and command execution section, as most of it is dealt with there, I also have my helper function, which scans the arguments for redirection operators, with pointers passed as arguments to address the case where a redirection operator is in the command. First, the function loops through all the characters in the command, which seems reasonable, and checks for “<” or “>”. As the project mentions, we don’t need to worry about a case where there are both operators in a command, so once we see one, we don’t have to worry about the other. If the operator is “<”, the input file pointer is set to the index one after the operator, which will properly capture the name of the given file. Then, the position of the operator is set as null in order to ensure proper reading of the command later. The same concept applies to “>”, where the output file pointer is set to the index after the operator, and the operator’s position is set to null. The rest is explained above in the child process creation and command execution section.

VI. Process Communication via Pipes
This requirement is to allow the output of one command to serve as input to another using a pipe. It’s one of the checks in my main method: a pipe is checked for, and if one is present, it will be handled in a separate function, and the loop will skip to the next iteration. The function (handle_pipe) first checks for a pipe by iterating through the command. If found, the index is stored in a variable. If there's no pipe, the function returns false; otherwise, it separates the commands and creates a pipe using the pipe_ends array with a read and write end (pipe_ends[0] read, pipe_ends[1] write). From there, a fork is called to deal with the left command. The child process closes the read end of fd (since this process only writes), and redirects stdout to the pipe’s write end using the dup2 system call. The write end is then closed, and execvp executes the left-hand command. The same concept is used on the right: A fork whose child process first closes the write end (since this process only reads), redirecting stdin to the pipe's read end, closing the read end, and using execvp to execute the right-hand command. After both sides are processed, both pipe ends are closed, and the parent waits for both children to finish. (uses waitpid to be specific).

VII. Command History Management
The final requirement was command history management using arrow keys, which requires an understanding of canonical versus non-canonical input processing. For our use case, it is best to operate in non-canonical mode, as it allows processing input character-by-character—an essential feature for handling history navigation with arrow keys. We can do this by storing the canonical settings in a struct using the termios library, adding a condition that at exit, canonical mode is restored, and swapping the mode to non-canonical for the duration of the program. Both of these have functions implemented for them. From here, we need to actually process the input character by character, which is done in the get input function. First, the input is reset to remove anything that was there previously. After, I simulate five up arrow and down arrow key presses to guarantee a fully reset browser state. This mitigates the chances of the history pointer displaying the incorrect ordering or starting position of commands. From there, an infinite loop is run, which reads a single character at a time from the stdin file that was implemented in the section above that enabled noncanonical mode. (Essentially reads every character the user inputted). If no characters are read, the loop exits. From there, the first special instance is handled: enter. If enter is detected (\n or \r), we move to a new line, the input terminates, and we break out of the loop. Next, backspace/delete is handled, and if the character is sensed (and there’s currently a count), one character is erased from the terminal (by using \b to move the cursor back, write in a space, and use \b to move it back again). Next, the up arrow case is handled. For context, the character combination is ‘[A’ for up arrows and ‘[B’ for down arrows. The logic essentially ensures there were previous commands, retrieves the most recent command in history, moves backward through stored commands when up is pressed, and updates the terminal display. This is done by clearing the line and moving the cursor to the beginning(printf("\33[2K\r");), copying the command from the buffer we implemented to store the command history, updating the character count, and printing the command. The logic is very similar for the down arrow, but has the edge case of the newest command as opposed to the oldest, like the up arrow. It follows the same procedure of clearing the line, moving the cursor, copying the needed command, updating the character count, and again printing the necessary command. After all the special cases have been dealt with, we handle regular characters by simply storing them in the input, updating count, and printing them as we go. 
